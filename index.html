<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LiveTile - Seamless Background Visualizer</title>
<style>
  :root {
    --grid-n: 3;
    --gap: 0px; /* no gutter by default */
    --overlay-opacity: 0.9;
  }
  html,body{
    height:100%;
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    background: #111;
    color: #eee;
    -webkit-font-smoothing:antialiased;
  }

  /* Top bar */
  .topbar {
    position:fixed;
    left:0; right:0;
    top:10px;
    display:flex;
    justify-content:center;
    pointer-events:none;
    z-index:30;
  }
  .topbar .info {
    background: rgba(0,0,0,0.5);
    padding:8px 12px;
    border-radius:8px;
    font-weight:600;
    pointer-events:auto;
    display:flex;
    gap:12px;
    align-items:center;
    min-width: 140px;
    justify-content:center;
  }
  .topbar button { pointer-events:auto; }

  /* Center area: largest square that fits viewport with margin */
  .stage-wrap {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    box-sizing:border-box;
  }

  .stage {
    width:100%;
    max-width:calc(100vh - 80px); /* ensure it remains square within viewport height */
    max-height:calc(100vw - 80px);
    aspect-ratio:1 / 1;
    background: linear-gradient(180deg,#222,#111);
    overflow:hidden;
    border-radius:8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    touch-action: none; /* we'll handle pinch/drag manually */
    position:relative;
  }

  .drop-hint {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    color: #bbb;
    font-size:14px;
    pointer-events:none;
    text-align:center;
    padding:12px;
  }

  /* Tiles are no longer used */
  .tile {}

  /* temporary overlay when zoom changes */
  .zoom-overlay {
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    background: rgba(0,0,0,0.6);
    padding:12px 18px;
    border-radius:10px;
    font-size:20px;
    font-weight:700;
    opacity:0;
    pointer-events:none;
    transition:opacity 200ms ease;
    z-index:40;
  }
  .zoom-overlay.show { opacity:1; }

  /* File info / small UI bottom-left */
  .meta {
    position:fixed;
    left:12px;
    bottom:12px;
    background: rgba(0,0,0,0.45);
    padding:8px 10px;
    border-radius:8px;
    font-size:13px;
    z-index:30;
  }

  .controls {
    display:flex;
    gap:8px;
    align-items:center;
    margin-left: 12px; /* Separate from view controls */
  }

  .view-controls {
    display: flex;
    gap: 4px;
  }

  input[type="file"] { display:none; }
  .file-btn {
    background: #1f6feb;
    color:white;
    padding:6px 10px;
    border-radius:6px;
    cursor:pointer;
    font-weight:600;
    border:none;
  }

  .watch-btn {
    background:#2a2a2a;
    color:#ddd;
    border:1px solid rgba(255,255,255,0.06);
    padding:6px 10px;
    border-radius:6px;
    cursor:pointer;
    font-weight:600;
  }

  .icon-btn {
    background: #2a2a2a;
    border: 1px solid rgba(255,255,255,0.1);
    color: #eee;
    cursor: pointer;
    padding: 6px;
    border-radius: 4px;
    display: flex;
    align-items: center;
  }
  .icon-btn:hover {
    background: #3a3a3a;
  }
  .icon-btn.active {
    background: #1f6feb;
    border-color: #1f6feb;
  }

  .grid-size-select {
    background: #2a2a2a;
    color: #eee;
    border: 1px solid rgba(255,255,255,0.1);
    padding: 4px 8px;
    border-radius: 4px;
    font-weight: 600;
    -webkit-appearance: none;
    appearance: none;
    text-align: center;
  }

  .small {
    font-size:12px;
    opacity:0.9;
  }

  /* instructions */
  .instructions {
    position:fixed;
    right:12px;
    bottom:12px;
    background: rgba(0,0,0,0.45);
    padding:8px 10px;
    border-radius:8px;
    font-size:12px;
    z-index:30;
    max-width:260px;
  }

  /* responsive */
  @media (max-width:600px){
    .topbar .info { font-size:13px; padding:6px 10px; }
    .zoom-overlay { font-size:18px; }
    .instructions { display:none; }
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="info" id="topInfo">
      Grid: <select id="gridSizeSelect" class="grid-size-select"></select>
      <div class="view-controls">
        <button id="gridToggleBtn" class="icon-btn" title="Toggle grid (G)">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M0 0h4v4H0zM6 0h4v4H6zM12 0h4v4h-4zM0 6h4v4H0zM6 6h4v4H6zM12 6h4v4h-4zM0 12h4v4H0zM6 12h4v4H6zM12 12h4v4h-4z"/></svg>
        </button>
        <button id="resetViewBtn" class="icon-btn" title="Reset View (R)">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M0 0h5v1H1v4H0V0z M16 0h-5v1h4v4h1V0z M0 16h5v-1H1v-4H0v5z M16 16h-5v-1h4v-4h1v5z"/></svg>
        </button>
      </div>
      <div class="controls">
        <button id="chooseFileBtn" class="file-btn">Choose file</button>
        <button id="clearBtn" class="watch-btn">Clear</button>
      </div>
    </div>
  </div>

  <div class="stage-wrap">
    <div id="stage" class="stage" tabindex="0" aria-label="Tiled image stage" >
      <div class="drop-hint" id="dropHint">Drag & drop an image here, or click "Choose file" to enable live updates.</div>
      <div class="zoom-overlay" id="zoomOverlay">3 × 3</div>
    </div>
  </div>

  <div class="meta" id="metaBox">
    <div id="fileName" class="small">No file</div>
    <div id="watchState" class="small">Not watching</div>
    <div class="small" style="margin-top:6px;">Zoom: + / - (or Home / End)</div>
    <div class="small" style="margin-top:2px;">Grid: G</div>
    <div class="small" style="margin-top:2px;">Reset View: R</div>
  </div>

  <div class="instructions">
    <div style="font-weight:700;margin-bottom:6px;">How to get live updates</div>
    <ol style="margin:0 0 0 16px;padding:0;font-size:13px;">
      <li>Drag & drop an image or click <b>Choose file</b> to load it.</li>
      <li>Edit the file in another app and it will update here automatically.</li>
    </ol>
  </div>

<canvas id="colorSampler" style="display:none;"></canvas>

<script>
/* ========== Configuration ========== */
const config = {
  MIN_N: 0.25,
  MAX_N: 10,
  DEFAULT_N: 3,
  POLL_MS: 200,
  ZOOM_AMOUNT: 1.1,
  LUMINANCE_THRESHOLD: 128,
  LIGHT_GRID_COLOR: 'rgba(255,255,255,0.25)',
  DARK_GRID_COLOR: 'rgba(0,0,0,0.25)'
};

/* ========== State ========== */
let N = config.DEFAULT_N;
let fileHandle = null;
let lastModified = 0;
let objectURL = null;
let watching = false;
let pollTimer = null;
let gridVisible = false;
let gridLineColor = config.DARK_GRID_COLOR;
let imageSize = { width: 0, height: 0 };

// Panning state
let isPanning = false;
let panStart = { x: 0, y: 0 };
let panOffset = { x: 0, y: 0 };
let panOffsetAtDragStart = { x: 0, y: 0 };

// Touch state
let pinchState = null;

/* ========== DOM Elements ========== */
const stage = document.getElementById('stage');
const gridSizeSelect = document.getElementById('gridSizeSelect');
const zoomOverlay = document.getElementById('zoomOverlay');
const dropHint = document.getElementById('dropHint');
const chooseFileBtn = document.getElementById('chooseFileBtn');
const clearBtn = document.getElementById('clearBtn');
const gridToggleBtn = document.getElementById('gridToggleBtn');
const resetViewBtn = document.getElementById('resetViewBtn');
const fileNameEl = document.getElementById('fileName');
const watchStateEl = document.getElementById('watchState');

/* ========== Helpers ========== */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function showOverlay(text, duration=700){
  zoomOverlay.textContent = text;
  zoomOverlay.classList.add('show');
  clearTimeout(zoomOverlay._to);
  zoomOverlay._to = setTimeout(()=>zoomOverlay.classList.remove('show'), duration);
}

function updateTop() {
  if (N >= 1) {
    gridSizeSelect.value = Math.round(N);
  } else {
    gridSizeSelect.value = 1;
  }
}

function updateMetaFile(name){
  fileNameEl.textContent = name ? name : 'No file';
  watchStateEl.textContent = watching ? 'Watching (live)' : 'Not watching';
}

/* ========== Core Logic ========== */
function updatePanPosition() {
  const pos = `${panOffset.x}px ${panOffset.y}px`;
  if (!stage.style.backgroundImage || stage.style.backgroundImage === 'none') {
    return;
  }
  const numLayers = stage.style.backgroundImage.split(',').length;
  stage.style.backgroundPosition = Array(numLayers).fill(pos).join(', ');
}

function updateStageBackground() {
    const stageRect = stage.getBoundingClientRect();
    if (stageRect.width === 0) { setTimeout(updateStageBackground, 50); return; }

    let imageTileWidth = 0;
    let imageTileHeight = 0;

    if (objectURL && imageSize.width > 0) {
        const imageAspectRatio = imageSize.width / imageSize.height;
        imageTileWidth = stageRect.width / N;
        imageTileHeight = imageTileWidth / imageAspectRatio;
    }

    const bgImages = [];
    const bgSizes = [];
    const bgRepeats = [];

    if (gridVisible && imageTileWidth > 0) {
        bgImages.push(`linear-gradient(${gridLineColor} 1px, transparent 1px)`);
        bgSizes.push(`${imageTileWidth}px ${imageTileHeight}px`);
        bgRepeats.push('repeat');
        bgImages.push(`linear-gradient(90deg, ${gridLineColor} 1px, transparent 1px)`);
        bgSizes.push(`${imageTileWidth}px ${imageTileHeight}px`);
        bgRepeats.push('repeat');
    }

    if (objectURL && imageTileWidth > 0) {
        bgImages.push(`url("${objectURL}")`);
        bgSizes.push(`${imageTileWidth}px ${imageTileHeight}px`);
        bgRepeats.push('repeat');
    }

    bgImages.push('linear-gradient(180deg, #222, #111)');
    bgSizes.push('cover');
    bgRepeats.push('no-repeat');

    stage.style.backgroundImage = bgImages.join(', ');
    stage.style.backgroundSize = bgSizes.join(', ');
    stage.style.backgroundRepeat = bgRepeats.join(', ');

    updatePanPosition();
}

function resetState() {
  stopPolling();
  if (objectURL) {
    URL.revokeObjectURL(objectURL);
    objectURL = null;
  }
  fileHandle = null;
  imageSize = { width: 0, height: 0 };
  panOffset = { x: 0, y: 0 };
  N = config.DEFAULT_N;
  updateTop();
  updateStageBackground();
  updateMetaFile(null);
  dropHint.style.display = 'flex';
}

function resetView() {
  panOffset = { x: 0, y: 0 };
  N = config.DEFAULT_N;
  updateTop();
  updateStageBackground();
  showOverlay('View Reset');
}

function toggleGrid() {
  gridVisible = !gridVisible;
  updateStageBackground();
  gridToggleBtn.classList.toggle('active', gridVisible);
}

function refreshTiles(newUrl, { resetView = false } = {}){
  if(objectURL && objectURL !== newUrl){ URL.revokeObjectURL(objectURL); }
  objectURL = newUrl;

  if (resetView) {
    panOffset = { x: 0, y: 0 };
    N = config.DEFAULT_N;
    updateTop();
  }

  const img = new Image();
  img.onload = () => {
    imageSize = { width: img.naturalWidth, height: img.naturalHeight };

    const canvas = document.getElementById('colorSampler');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    ctx.drawImage(img, 0, 0);

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    let totalLuminance = 0;
    for (let i = 0; i < data.length; i += 4) {
      const luminance = 0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2];
      totalLuminance += luminance;
    }
    const avgLuminance = totalLuminance / (data.length / 4);

    gridLineColor = (avgLuminance < config.LUMINANCE_THRESHOLD) ? config.LIGHT_GRID_COLOR : config.DARK_GRID_COLOR;

    updateStageBackground();
  };
  img.onerror = () => {
    console.error("Failed to load image for color analysis.");
    gridLineColor = config.DARK_GRID_COLOR;
    updateStageBackground();
  }
  img.src = newUrl;

  dropHint.style.display = 'none';
}

/* ========== File Handling & System ========== */
async function loadFileFromHandle(handle) {
  fileHandle = handle;
  if (!fileHandle) return;

  try {
    const permission = await fileHandle.queryPermission({ mode: 'read' });
    if (permission !== 'granted') {
      await fileHandle.requestPermission({ mode: 'read' });
    }

    const file = await fileHandle.getFile();
    lastModified = file.lastModified || Date.now();
    const url = URL.createObjectURL(file);
    refreshTiles(url, { resetView: true });
    watching = true;
    updateMetaFile(fileHandle.name);
    startPolling();
    showOverlay(`${N} × ${N}`);
  } catch (err) {
    console.error('Error loading file:', err);
    alert('Could not load the file. Please try again.');
  }
}

async function startPolling() {
  if (!fileHandle) {
    watching = false;
    return;
  }
  watching = true;
  updateMetaFile(fileHandle.name);
  if (pollTimer) clearInterval(pollTimer);
  pollTimer = setInterval(async () => {
    try {
      const f = await fileHandle.getFile();
      if (!f) return;
      if (f.lastModified !== lastModified) {
        lastModified = f.lastModified;
        const url = URL.createObjectURL(f);
        refreshTiles(url, { resetView: false });
      }
    } catch (err) {
      console.warn('Polling error', err);
      stopPolling();
    }
  }, config.POLL_MS);
}

function stopPolling() {
  if (pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
  }
  watching = false;
  updateMetaFile(fileHandle ? fileHandle.name || 'file' : null);
}

/* ========== Event Listeners ========== */
function preventEv(e) {
  e.preventDefault();
  e.stopPropagation();
}
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => {
  window.addEventListener(ev, preventEv);
});

window.addEventListener('drop', async ev => {
  preventEv(ev);
  const dt = ev.dataTransfer;
  if (!dt) return;

  if (dt.items && dt.items[0] && typeof dt.items[0].getAsFileSystemHandle === 'function') {
    try {
      const handle = await dt.items[0].getAsFileSystemHandle();
      if (handle && handle.kind === 'file') {
        await loadFileFromHandle(handle);
        return;
      }
    } catch (err) {
      console.warn('Could not get file handle from drop', err);
    }
  }

  const file = dt.files && dt.files[0];
  if (file && file.type.startsWith('image/')) {
    const url = URL.createObjectURL(file);
    refreshTiles(url, { resetView: true });
    showOverlay(`${N} × ${N}`);
    updateMetaFile(file.name);
    watching = false;
    stopPolling();
  } else {
    alert('Please drop an image file (PNG / JPEG).');
  }
});

chooseFileBtn.addEventListener('click', async () => {
  if (!window.showOpenFilePicker) {
    alert(
      'Your browser does not support the File System Access API. Use a Chromium-based browser (Chrome/Edge) and load the page via http://localhost for full functionality.'
    );
    return;
  }
  try {
    const [handle] = await window.showOpenFilePicker({
      types: [
        {
          description: 'Images',
          accept: { 'image/*': ['.png', '.jpg', '.jpeg', '.webp', '.bmp'] },
        },
      ],
      excludeAcceptAllOption: false,
      multiple: false,
    });
    if (handle) {
      await loadFileFromHandle(handle);
    }
  } catch (err) {
    console.error('File picker cancelled or failed', err);
  }
});

clearBtn.addEventListener('click', () => {
  resetState();
});

gridToggleBtn.addEventListener('click', () => {
  toggleGrid();
});

resetViewBtn.addEventListener('click', () => {
  resetView();
});

gridSizeSelect.addEventListener('change', e => {
  const newN = parseInt(e.target.value, 10);
  setN(newN);
});

function setN(newN, { fromUser=true } = {}){
  const oldN = N;
  const clamped = clamp(newN, config.MIN_N, config.MAX_N);
  if(clamped === N) return;
  N = clamped;

  if (objectURL) {
    const stageRect = stage.getBoundingClientRect();
    const anchorX = stageRect.width / 2;
    const anchorY = stageRect.height / 2;
    const ratio = oldN / N;

    panOffset.x = anchorX * (1 - ratio) + panOffset.x * ratio;
    panOffset.y = anchorY * (1 - ratio) + panOffset.y * ratio;
  }

  updateTop();
  updateStageBackground();

  if(fromUser) {
    if (N >= 1) {
      showOverlay(`${Math.round(N)} × ${Math.round(N)}`);
    } else {
      const zoomFactor = 1 / N;
      showOverlay(`${zoomFactor.toFixed(1)}x Zoom`);
    }
  }
}

window.addEventListener('keydown', (e)=>{
  if(e.key === '+' || e.key === '=' ){
    e.preventDefault();
    setN(N+1);
  } else if(e.key === '-' ){
    e.preventDefault();
    setN(N-1);
  } else if(e.key === 'Home'){
    e.preventDefault();
    setN(config.MIN_N);
  } else if(e.key === 'End'){
    e.preventDefault();
    setN(config.MAX_N);
  } else if (e.key === 'g' || e.key === 'G') {
    e.preventDefault();
    toggleGrid();
  } else if (e.key === 'r' || e.key === 'R') {
    e.preventDefault();
    resetView();
  }
});

stage.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const delta = e.deltaY;
  if(delta === 0) return;
  if(delta < 0){
    setN(N / config.ZOOM_AMOUNT);
  } else {
    setN(N * config.ZOOM_AMOUNT);
  }
}, { passive:false });

stage.addEventListener('mousedown', (e)=>{
  if (e.button === 0 && objectURL) { // left mouse
    e.preventDefault();
    isPanning = true;
    panStart.x = e.clientX;
    panStart.y = e.clientY;
    panOffsetAtDragStart.x = panOffset.x;
    panOffsetAtDragStart.y = panOffset.y;
    stage.style.cursor = 'grabbing';
  }
});

window.addEventListener('mousemove', (e)=>{
  if (isPanning) {
    e.preventDefault();
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    panOffset.x = panOffsetAtDragStart.x + dx;
    panOffset.y = panOffsetAtDragStart.y + dy;
    updatePanPosition();
  }
});

window.addEventListener('mouseup', (e)=>{
  if (isPanning && e.button === 0) { // left mouse
    isPanning = false;
    stage.style.cursor = 'default';
  }
});

function getDistance(t1, t2){
  const dx = t2.clientX - t1.clientX;
  const dy = t2.clientY - t1.clientY;
  return Math.hypot(dx, dy);
}

stage.addEventListener('touchstart', (ev)=>{
  if(ev.touches.length === 2){
    pinchState = {
      startDist: getDistance(ev.touches[0], ev.touches[1]),
      lastApplied: N
    };
  }
}, { passive:false });

stage.addEventListener('touchmove', (ev)=>{
  if(ev.touches.length === 2 && pinchState){
    ev.preventDefault();
    const curDist = getDistance(ev.touches[0], ev.touches[1]);
    const ratio = curDist / pinchState.startDist;
    const step = Math.round(Math.log2(ratio) / Math.log2(1.12));
    if(step !== 0){
      const target = clamp(pinchState.lastApplied + step, config.MIN_N, config.MAX_N);
      if(target !== N){
        setN(target);
        pinchState.lastApplied = target;
      }
    }
  }
}, { passive:false });

stage.addEventListener('touchend', (ev)=>{
  if(ev.touches.length < 2){
    pinchState = null;
  }
});

/* ========== Initialization ========== */
for (let i = 1; i <= config.MAX_N; i++) {
  const option = document.createElement('option');
  option.value = i;
  option.textContent = `${i} × ${i}`;
  gridSizeSelect.appendChild(option);
}

updateTop();
updateStageBackground();
updateMetaFile(null);

/* Expose minimal public API for debug (optional) */
window._liveGrid = {
  setN, updateStageBackground
};
</script>
</body>
</html>