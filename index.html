<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LiveTile - Seamless Background Visualizer</title>
<style>
  /* ========== Root Variables ========== */
  :root {
    --grid-n: 3;
    --gap: 0px; /* no gutter by default */
    --overlay-opacity: 0.9;
  }

  /* ========== General ========== */
  html,body{
    height:100%;
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    background: #111;
    color: #eee;
    -webkit-font-smoothing:antialiased;
  }

  input[type="file"] { display:none; }

  /* ========== Layout ========== */
  .topbar {
    position:fixed;
    left:0; right:0;
    top:10px;
    display:flex;
    justify-content:center;
    pointer-events:none;
    z-index:30;
  }

  .stage-wrap {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    box-sizing:border-box;
  }

  .stage {
    width:100%;
    max-width:calc(100vh - 80px);
    max-height:calc(100vw - 80px);
    aspect-ratio:1 / 1;
    background: linear-gradient(180deg,#222,#111);
    overflow:hidden;
    border-radius:8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    touch-action: none;
    position:relative;
  }

  /* ========== Components ========== */
  .info {
    background: rgba(0,0,0,0.5);
    padding:8px 12px;
    border-radius:8px;
    font-weight:600;
    pointer-events:auto;
    display:flex;
    gap:12px;
    align-items:center;
    min-width: 140px;
    justify-content:center;
  }

  .drop-hint {
    position:absolute;
    inset:0;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:12px;
    color: #bbb;
    font-size:14px;
    pointer-events:none;
    text-align:center;
    padding:12px;
  }

  .drop-hint svg {
    width: 48px;
    height: 48px;
    opacity: 0.4;
  }

  .zoom-overlay {
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    background: rgba(0,0,0,0.6);
    padding:12px 18px;
    border-radius:10px;
    font-size:20px;
    font-weight:700;
    opacity:0;
    pointer-events:none;
    transition:opacity 200ms ease;
    z-index:40;
  }

  #colorSampler {
    display: none;
  }

  .instructions {
    position:fixed;
    right:12px;
    bottom:12px;
    background: rgba(0,0,0,0.45);
    padding:10px 12px;
    border-radius:8px;
    font-size:12px;
    z-index:30;
    max-width:280px;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 8px;
  }

  .instructions-header {
    font-weight: 700;
    margin-bottom: 6px;
  }

  .attribution {
    margin-top: 10px;
    font-size: 12px;
  }

  /* ========== Controls & Links ========== */
  .controls {
    display:flex;
    gap:8px;
    align-items:center;
    margin-left: 12px;
  }

  .view-controls {
    display: flex;
    gap: 4px;
  }

  .file-btn {
    background: #1f6feb;
    color:white;
    padding:6px 10px;
    border-radius:6px;
    cursor:pointer;
    font-weight:600;
    border:none;
  }

  .watch-btn {
    background:#2a2a2a;
    color:#ddd;
    border:1px solid rgba(255,255,255,0.06);
    padding:6px 10px;
    border-radius:6px;
    cursor:pointer;
    font-weight:600;
  }

  .icon-btn {
    background: #2a2a2a;
    border: 1px solid rgba(255,255,255,0.1);
    color: #eee;
    cursor: pointer;
    padding: 6px;
    border-radius: 4px;
    display: flex;
    align-items: center;
  }

  .grid-size-select {
    background: #2a2a2a;
    color: #eee;
    border: 1px solid rgba(255,255,255,0.1);
    padding: 4px 8px;
    border-radius: 4px;
    font-weight: 600;
    -webkit-appearance: none;
    appearance: none;
    text-align: center;
  }

  .credit-link {
    display: flex;
    align-items: center;
    gap: 4px;
    color: #eee;
    text-decoration: none;
  }

  /* ========== States & Modifiers ========== */
  .zoom-overlay.show { opacity:1; }
  .small { font-size:12px; opacity:0.9; }

  .icon-btn:hover {
    background: #3a3a3a;
  }

  .icon-btn.active {
    background: #1f6feb;
    border-color: #1f6feb;
  }

  button:disabled,
  select:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .credit-link:hover {
    color: #1f6feb;
  }

  .credit-link b {
    font-weight: 600;
    text-decoration: underline;
  }

  /* ========== Responsive ========== */
  @media (max-width:600px){
    .topbar .info { font-size:13px; padding:6px 10px; }
    .zoom-overlay { font-size:18px; }
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="info" id="topInfo">
      Grid: <select id="gridSizeSelect" class="grid-size-select"></select>
      <div class="view-controls">
        <button id="gridToggleBtn" class="icon-btn" title="Toggle grid (G)">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M0 0h4v4H0zM6 0h4v4H6zM12 0h4v4h-4zM0 6h4v4H0zM6 6h4v4H6zM12 6h4v4h-4zM0 12h4v4H0zM6 12h4v4H6zM12 12h4v4h-4z"/></svg>
        </button>
        <button id="resetViewBtn" class="icon-btn" title="Reset View (R)">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M0 0h5v1H1v4H0V0z M16 0h-5v1h4v4h1V0z M0 16h5v-1H1v-4H0v5z M16 16h-5v-1h4v-4h1v5z"/></svg>
        </button>
      </div>
      <div class="controls">
        <button id="chooseFileBtn" class="file-btn">Choose file</button>
        <button id="clearBtn" class="watch-btn">Clear</button>
      </div>
    </div>
  </div>

  <div class="stage-wrap">
    <div id="stage" class="stage" tabindex="0" aria-label="Tiled image stage" >
      <div class="drop-hint" id="dropHint">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        <span>Drag & drop an image here, or click "Choose file" to begin.</span>
      </div>
      <div class="zoom-overlay" id="zoomOverlay">3 × 3</div>
    </div>
  </div>

  <div class="instructions">
    <div id="fileName" class="small">No file</div>
    <div id="watchState" class="small">Not watching</div>
    <div class="small"><b>Pan:</b> Hold & Drag</div>
    <div class="small"><b>Zoom:</b> Wheel or +/-</div>
    <div class="small"><b>Show/Hide Grid:</b> G</div>
    <div class="small"><b>Reset View:</b> R</div>
    <div class="attribution">
      <a href="https://github.com/shirleyman/live-tile" title="View on GitHub" class="credit-link">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
        <span>Created by <b>Shirley Man</b></span>
      </a>
    </div>
  </div>

<canvas id="colorSampler"></canvas>
<input type="file" id="fallbackFileInput" accept="image/*" />

<script>
/* ========== Configuration ========== */
const config = {
  MIN_N: 0.25,
  MAX_N: 10,
  DEFAULT_N: 3,
  POLL_MS: 200,
  ZOOM_AMOUNT: 1.1,
  LUMINANCE_THRESHOLD: 128,
  LIGHT_GRID_COLOR: 'rgba(255,255,255,0.25)',
  DARK_GRID_COLOR: 'rgba(0,0,0,0.25)'
};

/* ========== State ========== */
let N = config.DEFAULT_N;
let fileHandle = null;
let lastModified = 0;
let objectURL = null;
let watching = false;
let pollTimer = null;
let gridVisible = false;
let gridLineColor = config.DARK_GRID_COLOR;
let imageSize = { width: 0, height: 0 };

// Panning state
let isPanning = false;
let panStart = { x: 0, y: 0 };
let panOffset = { x: 0, y: 0 };
let panOffsetAtDragStart = { x: 0, y: 0 };

// Touch state
let pinchState = null;

/* ========== DOM Elements ========== */
const stage = document.getElementById('stage');
const gridSizeSelect = document.getElementById('gridSizeSelect');
const zoomOverlay = document.getElementById('zoomOverlay');
const dropHint = document.getElementById('dropHint');
const chooseFileBtn = document.getElementById('chooseFileBtn');
const clearBtn = document.getElementById('clearBtn');
const gridToggleBtn = document.getElementById('gridToggleBtn');
const resetViewBtn = document.getElementById('resetViewBtn');
const fileNameEl = document.getElementById('fileName');
const watchStateEl = document.getElementById('watchState');
const fallbackFileInput = document.getElementById('fallbackFileInput');

/* ========== Helpers ========== */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function showOverlay(text, duration=700){
  zoomOverlay.textContent = text;
  zoomOverlay.classList.add('show');
  clearTimeout(zoomOverlay._to);
  zoomOverlay._to = setTimeout(()=>zoomOverlay.classList.remove('show'), duration);
}

function updateTop() {
  if (N >= 1) {
    gridSizeSelect.value = Math.round(N);
  } else {
    gridSizeSelect.value = 1;
  }
}

function updateMetaFile(name){
  fileNameEl.textContent = name ? name : 'No file';
  if (!window.showOpenFilePicker) {
    watchStateEl.textContent = 'Live update not supported';
  } else {
    watchStateEl.textContent = watching ? 'Watching (live)' : 'Not watching';
  }
}

function updateControlsState() {
  const hasImage = !!objectURL;
  gridSizeSelect.disabled = !hasImage;
  gridToggleBtn.disabled = !hasImage;
  resetViewBtn.disabled = !hasImage;
  clearBtn.disabled = !hasImage;
}

/* ========== Core Logic ========== */
function updatePanPosition() {
  const pos = `${panOffset.x}px ${panOffset.y}px`;
  if (!stage.style.backgroundImage || stage.style.backgroundImage === 'none') {
    return;
  }
  const numLayers = stage.style.backgroundImage.split(',').length;
  stage.style.backgroundPosition = Array(numLayers).fill(pos).join(', ');
}

function updateStageBackground() {
    const stageRect = stage.getBoundingClientRect();
    if (stageRect.width === 0) { setTimeout(updateStageBackground, 50); return; }

    let imageTileWidth = 0;
    let imageTileHeight = 0;

    if (objectURL && imageSize.width > 0) {
        const imageAspectRatio = imageSize.width / imageSize.height;
        imageTileWidth = stageRect.width / N;
        imageTileHeight = imageTileWidth / imageAspectRatio;
    }

    const bgImages = [];
    const bgSizes = [];
    const bgRepeats = [];

    if (gridVisible && imageTileWidth > 0) {
        bgImages.push(`linear-gradient(${gridLineColor} 1px, transparent 1px)`);
        bgSizes.push(`${imageTileWidth}px ${imageTileHeight}px`);
        bgRepeats.push('repeat');
        bgImages.push(`linear-gradient(90deg, ${gridLineColor} 1px, transparent 1px)`);
        bgSizes.push(`${imageTileWidth}px ${imageTileHeight}px`);
        bgRepeats.push('repeat');
    }

    if (objectURL && imageTileWidth > 0) {
        bgImages.push(`url("${objectURL}")`);
        bgSizes.push(`${imageTileWidth}px ${imageTileHeight}px`);
        bgRepeats.push('repeat');
    }

    bgImages.push('linear-gradient(180deg, #222, #111)');
    bgSizes.push('cover');
    bgRepeats.push('no-repeat');

    stage.style.backgroundImage = bgImages.join(', ');
    stage.style.backgroundSize = bgSizes.join(', ');
    stage.style.backgroundRepeat = bgRepeats.join(', ');

    updatePanPosition();
}

function resetState() {
  stopPolling();
  if (objectURL) {
    URL.revokeObjectURL(objectURL);
    objectURL = null;
  }
  fileHandle = null;
  imageSize = { width: 0, height: 0 };
  panOffset = { x: 0, y: 0 };
  N = config.DEFAULT_N;
  updateTop();
  updateStageBackground();
  updateMetaFile(null);
  updateControlsState();
  dropHint.style.display = 'flex';
}

function resetView() {
  panOffset = { x: 0, y: 0 };
  N = config.DEFAULT_N;
  updateTop();
  updateStageBackground();
  showOverlay('Reset View');
}

function toggleGrid() {
  gridVisible = !gridVisible;
  updateStageBackground();
  gridToggleBtn.classList.toggle('active', gridVisible);
}

function refreshTiles(newUrl, { resetView = false } = {}){
  if(objectURL && objectURL !== newUrl){ URL.revokeObjectURL(objectURL); }
  objectURL = newUrl;

  if (resetView) {
    panOffset = { x: 0, y: 0 };
    N = config.DEFAULT_N;
    updateTop();
  }

  const img = new Image();
  img.onload = () => {
    imageSize = { width: img.naturalWidth, height: img.naturalHeight };

    const canvas = document.getElementById('colorSampler');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    ctx.drawImage(img, 0, 0);

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    let totalLuminance = 0;
    for (let i = 0; i < data.length; i += 4) {
      const luminance = 0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2];
      totalLuminance += luminance;
    }
    const avgLuminance = totalLuminance / (data.length / 4);

    gridLineColor = (avgLuminance < config.LUMINANCE_THRESHOLD) ? config.LIGHT_GRID_COLOR : config.DARK_GRID_COLOR;

    updateStageBackground();
  };
  img.onerror = () => {
    console.error("Failed to load image for color analysis.");
    gridLineColor = config.DARK_GRID_COLOR;
    updateStageBackground();
  }
  img.src = newUrl;

  dropHint.style.display = 'none';
  updateControlsState();
}

/* ========== File Handling & System ========== */
async function loadFileFromHandle(handle) {
  fileHandle = handle;
  if (!fileHandle) return;

  try {
    const permission = await fileHandle.queryPermission({ mode: 'read' });
    if (permission !== 'granted') {
      await fileHandle.requestPermission({ mode: 'read' });
    }

    const file = await fileHandle.getFile();
    lastModified = file.lastModified || Date.now();
    const url = URL.createObjectURL(file);
    refreshTiles(url, { resetView: true });
    watching = true;
    updateMetaFile(fileHandle.name);
    startPolling();
    showOverlay(`${N} × ${N}`);
  } catch (err) {
    console.error('Error loading file:', err);
    alert('Could not load the file. Please try again.');
  }
}

async function startPolling() {
  if (!fileHandle) {
    watching = false;
    return;
  }
  watching = true;
  updateMetaFile(fileHandle.name);
  if (pollTimer) clearInterval(pollTimer);
  pollTimer = setInterval(async () => {
    try {
      const f = await fileHandle.getFile();
      if (!f) return;
      if (f.lastModified !== lastModified) {
        lastModified = f.lastModified;
        const url = URL.createObjectURL(f);
        refreshTiles(url, { resetView: false });
      }
    } catch (err) {
      console.warn('Polling error', err);
      stopPolling();
    }
  }, config.POLL_MS);
}

function stopPolling() {
  if (pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
  }
  watching = false;
  updateMetaFile(fileHandle ? fileHandle.name || 'file' : null);
}

/* ========== Event Listeners ========== */
function preventEv(e) {
  e.preventDefault();
  e.stopPropagation();
}
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => {
  window.addEventListener(ev, preventEv);
});

window.addEventListener('drop', async ev => {
  preventEv(ev);
  const dt = ev.dataTransfer;
  if (!dt) return;

  if (dt.items && dt.items[0] && typeof dt.items[0].getAsFileSystemHandle === 'function') {
    try {
      const handle = await dt.items[0].getAsFileSystemHandle();
      if (handle && handle.kind === 'file') {
        await loadFileFromHandle(handle);
        return;
      }
    } catch (err) {
      console.warn('Could not get file handle from drop', err);
    }
  }

  const file = dt.files && dt.files[0];
  if (file && file.type.startsWith('image/')) {
    stopPolling();
    fileHandle = null;

    const url = URL.createObjectURL(file);
    refreshTiles(url, { resetView: true });
    showOverlay(`${N} × ${N}`);
    updateMetaFile(file.name);
  } else {
    alert('Please drop an image file (PNG / JPEG).');
  }
});

chooseFileBtn.addEventListener('click', async () => {
  if (window.showOpenFilePicker) {
    try {
      const [handle] = await window.showOpenFilePicker({
        types: [{
          description: 'Images',
          accept: { 'image/*': ['.png', '.jpg', '.jpeg', '.webp', '.bmp'] },
        }],
        excludeAcceptAllOption: false,
        multiple: false,
      });
      if (handle) {
        await loadFileFromHandle(handle);
      }
    } catch (err) {
      console.error('File picker cancelled or failed', err);
    }
  } else {
    fallbackFileInput.click();
  }
});

fallbackFileInput.addEventListener('change', (e) => {
  const file = e.target.files && e.target.files[0];
  if (file) {
    stopPolling();
    fileHandle = null;

    const url = URL.createObjectURL(file);
    refreshTiles(url, { resetView: true });
    showOverlay(`${N} × ${N}`);
    updateMetaFile(file.name);

    // Reset the input so the same file can be chosen again
    fallbackFileInput.value = '';
  }
});

clearBtn.addEventListener('click', () => {
  resetState();
});

gridToggleBtn.addEventListener('click', () => {
  toggleGrid();
});

resetViewBtn.addEventListener('click', () => {
  resetView();
});

gridSizeSelect.addEventListener('change', e => {
  const newN = parseInt(e.target.value, 10);
  setN(newN);
});

function setN(newN, { fromUser=true } = {}){
  const oldN = N;
  const clamped = clamp(newN, config.MIN_N, config.MAX_N);
  if(clamped === N) return;
  N = clamped;

  if (objectURL) {
    const stageRect = stage.getBoundingClientRect();
    const anchorX = stageRect.width / 2;
    const anchorY = stageRect.height / 2;
    const ratio = oldN / N;

    panOffset.x = anchorX * (1 - ratio) + panOffset.x * ratio;
    panOffset.y = anchorY * (1 - ratio) + panOffset.y * ratio;
  }

  updateTop();
  updateStageBackground();

  if(fromUser) {
    if (N >= 1) {
      showOverlay(`${Math.round(N)} × ${Math.round(N)}`);
    } else {
      const zoomFactor = 1 / N;
      showOverlay(`${zoomFactor.toFixed(1)}x Zoom`);
    }
  }
}

window.addEventListener('keydown', (e)=>{
  if(e.key === '+' || e.key === '=' ){
    e.preventDefault();
    setN(N+1);
  } else if(e.key === '-' ){
    e.preventDefault();
    setN(N-1);
  } else if(e.key === 'Home'){
    e.preventDefault();
    setN(config.MIN_N);
  } else if(e.key === 'End'){
    e.preventDefault();
    setN(config.MAX_N);
  } else if (e.key === 'g' || e.key === 'G') {
    e.preventDefault();
    toggleGrid();
  } else if (e.key === 'r' || e.key === 'R') {
    e.preventDefault();
    resetView();
  }
});

stage.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const delta = e.deltaY;
  if(delta === 0) return;
  if(delta < 0){
    setN(N / config.ZOOM_AMOUNT);
  } else {
    setN(N * config.ZOOM_AMOUNT);
  }
}, { passive:false });

/* ========== Panning (left/middle mouse) ========== */
stage.addEventListener('mousedown', (e)=>{
  // Allow panning with left (0) or middle (1) mouse button
  if ((e.button === 0 || e.button === 1) && objectURL) {
    e.preventDefault();
    isPanning = true;
    panStart.x = e.clientX;
    panStart.y = e.clientY;
    panOffsetAtDragStart.x = panOffset.x;
    panOffsetAtDragStart.y = panOffset.y;
    stage.style.cursor = 'grabbing';
  }
});

window.addEventListener('mousemove', (e)=>{
  if (isPanning) {
    e.preventDefault();
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    panOffset.x = panOffsetAtDragStart.x + dx;
    panOffset.y = panOffsetAtDragStart.y + dy;
    updatePanPosition();
  }
});

window.addEventListener('mouseup', (e)=>{
  // Stop panning on left (0) or middle (1) mouse button release
  if (isPanning && (e.button === 0 || e.button === 1)) {
    isPanning = false;
    stage.style.cursor = 'default';
  }
});

function getDistance(t1, t2){
  const dx = t2.clientX - t1.clientX;
  const dy = t2.clientY - t1.clientY;
  return Math.hypot(dx, dy);
}

stage.addEventListener('touchstart', (ev) => {
  if (!objectURL) return;
  preventEv(ev);

  if (ev.touches.length === 1) {
    const touch = ev.touches[0];
    isPanning = true;
    panStart.x = touch.clientX;
    panStart.y = touch.clientY;
    panOffsetAtDragStart.x = panOffset.x;
    panOffsetAtDragStart.y = panOffset.y;
    pinchState = null; // Ensure no pinch state
  } else if (ev.touches.length === 2) {
    isPanning = false; // Stop panning if a second finger is added
    pinchState = {
      startDist: getDistance(ev.touches[0], ev.touches[1]),
      startN: N,
    };
  }
}, { passive: false });

stage.addEventListener('touchmove', (ev) => {
  if (!objectURL) return;
  preventEv(ev);

  if (isPanning && ev.touches.length === 1) {
    const touch = ev.touches[0];
    const dx = touch.clientX - panStart.x;
    const dy = touch.clientY - panStart.y;
    panOffset.x = panOffsetAtDragStart.x + dx;
    panOffset.y = panOffsetAtDragStart.y + dy;
    updatePanPosition();
  } else if (pinchState && ev.touches.length === 2) {
    const curDist = getDistance(ev.touches[0], ev.touches[1]);
    const ratio = curDist / pinchState.startDist;
    if (pinchState.startDist > 0) {
      const newN = pinchState.startN / ratio;
      setN(newN, { fromUser: false });
    }
  }
}, { passive: false });

stage.addEventListener('touchend', (ev) => {
  if (ev.touches.length === 0) {
    // All fingers lifted
    isPanning = false;
    pinchState = null;
  } else if (ev.touches.length === 1) {
    // One finger remains (e.g., after a pinch)
    pinchState = null;
    // Start panning with the remaining finger
    const touch = ev.touches[0];
    isPanning = true;
    panStart.x = touch.clientX;
    panStart.y = touch.clientY;
    panOffsetAtDragStart.x = panOffset.x;
    panOffsetAtDragStart.y = panOffset.y;
  }
});

/* ========== Initialization ========== */
for (let i = 1; i <= config.MAX_N; i++) {
  const option = document.createElement('option');
  option.value = i;
  option.textContent = `${i} × ${i}`;
  gridSizeSelect.appendChild(option);
}

updateTop();
updateStageBackground();
updateMetaFile(null);
updateControlsState();

/* Expose minimal public API for debug (optional) */
window._liveGrid = {
  setN, updateStageBackground
};
</script>
</body>
</html>