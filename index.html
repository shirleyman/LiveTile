<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LiveTile - Seamless Background Visualizer</title>
<style>
  :root {
    --grid-n: 3;
    --gap: 0px; /* no gutter by default */
    --overlay-opacity: 0.9;
  }
  html,body{
    height:100%;
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    background: #111;
    color: #eee;
    -webkit-font-smoothing:antialiased;
  }

  /* Top bar */
  .topbar {
    position:fixed;
    left:0; right:0;
    top:10px;
    display:flex;
    justify-content:center;
    pointer-events:none;
    z-index:30;
  }
  .topbar .info {
    background: rgba(0,0,0,0.5);
    padding:8px 12px;
    border-radius:8px;
    font-weight:600;
    pointer-events:auto;
    display:flex;
    gap:12px;
    align-items:center;
    min-width: 140px;
    justify-content:center;
  }
  .topbar button { pointer-events:auto; }

  /* Center area: largest square that fits viewport with margin */
  .stage-wrap {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    box-sizing:border-box;
    gap:12px;
  }

  .stage {
    width:100%;
    max-width:calc(100vh - 80px); /* ensure it remains square within viewport height */
    max-height:calc(100vw - 80px);
    aspect-ratio:1 / 1;
    background: linear-gradient(180deg,#222,#111);
    display:grid;
    gap: var(--gap);
    overflow:hidden;
    border-radius:8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    touch-action: none; /* we'll handle pinch/drag manually */
    position:relative;
  }

  .drop-hint {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    color: #bbb;
    font-size:14px;
    pointer-events:none;
    text-align:center;
    padding:12px;
  }

  /* Tiles (we set grid-template dynamically in JS) */
  .tile {
    background-color: #333;

    background-repeat:repeat;
    background-size:cover;
    width:100%;
    height:100%;
  }

  /* temporary overlay when zoom changes */
  .zoom-overlay {
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    background: rgba(0,0,0,0.6);
    padding:12px 18px;
    border-radius:10px;
    font-size:20px;
    font-weight:700;
    opacity:0;
    pointer-events:none;
    transition:opacity 200ms ease;
    z-index:40;
  }
  .zoom-overlay.show { opacity:1; }

  /* File info / small UI bottom-left */
  .meta {
    position:fixed;
    left:12px;
    bottom:12px;
    background: rgba(0,0,0,0.45);
    padding:8px 10px;
    border-radius:8px;
    font-size:13px;
    z-index:30;
  }

  .controls {
    display:flex;
    gap:8px;
    align-items:center;
  }

  input[type="file"] { display:none; }
  .file-btn {
    background: #1f6feb;
    color:white;
    padding:6px 10px;
    border-radius:6px;
    cursor:pointer;
    font-weight:600;
    border:none;
  }

  .watch-btn {
    background:#2a2a2a;
    color:#ddd;
    border:1px solid rgba(255,255,255,0.06);
    padding:6px 10px;
    border-radius:6px;
    cursor:pointer;
    font-weight:600;
  }

  .icon-btn {
    background: #2a2a2a;
    border: 1px solid rgba(255,255,255,0.1);
    color: #eee;
    cursor: pointer;
    padding: 6px;
    border-radius: 4px;
    display: flex;
    align-items: center;
  }
  .icon-btn:hover {
    background: #3a3a3a;
  }
  .icon-btn.active {
    background: #1f6feb;
    border-color: #1f6feb;
  }

  .grid-size-select {
    background: #2a2a2a;
    color: #eee;
    border: 1px solid rgba(255,255,255,0.1);
    padding: 4px 8px;
    border-radius: 4px;
    font-weight: 600;
    -webkit-appearance: none;
    appearance: none;
    text-align: center;
  }

  .small {
    font-size:12px;
    opacity:0.9;
  }

  /* instructions */
  .instructions {
    position:fixed;
    right:12px;
    bottom:12px;
    background: rgba(0,0,0,0.45);
    padding:8px 10px;
    border-radius:8px;
    font-size:12px;
    z-index:30;
    max-width:260px;
  }

  /* responsive */
  @media (max-width:600px){
    .topbar .info { font-size:13px; padding:6px 10px; }
    .zoom-overlay { font-size:18px; }
    .instructions { display:none; }
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="info" id="topInfo">
      Grid: <select id="gridSizeSelect" class="grid-size-select"></select>
      <button id="gridToggleBtn" class="icon-btn" title="Toggle grid (G)">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M0 0h4v4H0zM6 0h4v4H6zM12 0h4v4h-4zM0 6h4v4H0zM6 6h4v4H6zM12 6h4v4h-4zM0 12h4v4H0zM6 12h4v4H6zM12 12h4v4h-4z"/></svg>
      </button>
      <div class="controls">
        <button id="chooseFileBtn" class="file-btn">Choose file</button>
        <button id="clearBtn" class="watch-btn">Clear</button>
      </div>
    </div>
  </div>

  <div class="stage-wrap">
    <div id="stage" class="stage" tabindex="0" aria-label="Tiled image stage" >
      <div class="drop-hint" id="dropHint">Drag & drop an image here, or click "Choose file" to enable live updates.</div>
      <div class="zoom-overlay" id="zoomOverlay">3 × 3</div>
    </div>
  </div>

  <div class="meta" id="metaBox">
    <div id="fileName" class="small">No file</div>
    <div id="watchState" class="small">Not watching</div>
    <div class="small" style="margin-top:6px;">Zoom: + / - (or Home / End)</div>
    <div class="small" style="margin-top:2px;">Grid: G</div>
  </div>

  <div class="instructions">
    <div style="font-weight:700;margin-bottom:6px;">How to get live updates</div>
    <ol style="margin:0 0 0 16px;padding:0;font-size:13px;">
      <li>Drag & drop an image or click <b>Choose file</b> to load it.</li>
      <li>Edit the file in another app and it will update here automatically.</li>
    </ol>
  </div>

<script>
/* ========== Configuration ========== */
const MIN_N = 1;
const MAX_N = 10;
const POLL_MS = 200; // throttle file polling

/* ========== State ========== */
let N = 3;
let fileHandle = null;      // FileSystemFileHandle when granted
let lastModified = 0;
let objectURL = null;
let watching = false;
let pollTimer = null;
let tiles = [];
let gridVisible = false;
let isPanning = false;
let panStart = { x: 0, y: 0 };
let panOffset = { x: 0, y: 0 };
let panOffsetAtDragStart = { x: 0, y: 0 };
const stage = document.getElementById('stage');
const gridSizeSelect = document.getElementById('gridSizeSelect');
const zoomOverlay = document.getElementById('zoomOverlay');
const dropHint = document.getElementById('dropHint');
const chooseFileBtn = document.getElementById('chooseFileBtn');
const clearBtn = document.getElementById('clearBtn');
const gridToggleBtn = document.getElementById('gridToggleBtn');
const fileNameEl = document.getElementById('fileName');
const watchStateEl = document.getElementById('watchState');

/* ========== Helpers ========== */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function showOverlay(text, duration=700){
  zoomOverlay.textContent = text;
  zoomOverlay.classList.add('show');
  clearTimeout(zoomOverlay._to);
  zoomOverlay._to = setTimeout(()=>zoomOverlay.classList.remove('show'), duration);
}
function updateTop() {
  gridSizeSelect.value = N;
}
function updateMetaFile(name){
  fileNameEl.textContent = name ? name : 'No file';
  watchStateEl.textContent = watching ? 'Watching (live)' : 'Not watching';
}

function resetState() {
  stopPolling();
  if (objectURL) {
    URL.revokeObjectURL(objectURL);
    objectURL = null;
  }
  fileHandle = null;
  panOffset = { x: 0, y: 0 };
  renderGrid();
  updateMetaFile(null);
  dropHint.style.display = 'flex';
}

function toggleGrid() {
  gridVisible = !gridVisible;
  stage.style.setProperty('--gap', gridVisible ? '1px' : '0px');
  gridToggleBtn.classList.toggle('active', gridVisible);
}

/* ========== Grid rendering ========== */
function renderGrid(){
  // clear children
  stage.innerHTML = '';
  stage.appendChild(dropHint);
  stage.appendChild(zoomOverlay);
  // compute template
  stage.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
  stage.style.gridTemplateRows = `repeat(${N}, 1fr)`;
  // create tiles
  tiles = [];
  const total = N * N;
  for(let i=0;i<total;i++){
    const d = document.createElement('div');
    d.className = 'tile';
    stage.appendChild(d);
    tiles.push(d);
  }

  if (objectURL) {
    const stageRect = stage.getBoundingClientRect();
    const gap = gridVisible ? 1 : 0;
    const tileWidth = (stageRect.width - (N - 1) * gap) / N;
    const tileHeight = (stageRect.height - (N - 1) * gap) / N;

    tiles.forEach((d, i) => {
      d.style.backgroundImage = `url("${objectURL}")`;
      const row = Math.floor(i / N);
      const col = i % N;
      const xPos = panOffset.x - (col * tileWidth);
      const yPos = panOffset.y - (row * tileHeight);
      d.style.backgroundPosition = `${xPos}px ${yPos}px`;
    });
  }
  updateTop();
}

/* Update tile images in-place */
function refreshTiles(newUrl){
  // revoke old
  if(objectURL && objectURL !== newUrl){ URL.revokeObjectURL(objectURL); }
  objectURL = newUrl;
  panOffset = { x: 0, y: 0 }; // Reset pan

  if (!tiles.length) {
    renderGrid();
    return;
  }

  const tileRect = tiles[0].getBoundingClientRect();
  if (tileRect.width === 0) { // Tiles not rendered yet
      setTimeout(() => refreshTiles(newUrl), 50); // Retry
      return;
  }
  const tileWidth = tileRect.width;
  const tileHeight = tileRect.height;

  tiles.forEach((t, i) => {
    t.style.backgroundImage = `url("${objectURL}")`;
    const row = Math.floor(i / N);
    const col = i % N;
    const xPos = -(col * tileWidth);
    const yPos = -(row * tileHeight);
    t.style.backgroundPosition = `${xPos}px ${yPos}px`;
  });
  dropHint.style.display = 'none';
}

/* ========== File handling ========== */
async function loadFileFromHandle(handle) {
  fileHandle = handle;
  if (!fileHandle) return;

  try {
    const permission = await fileHandle.queryPermission({ mode: 'read' });
    if (permission !== 'granted') {
      await fileHandle.requestPermission({ mode: 'read' });
    }

    const file = await fileHandle.getFile();
    lastModified = file.lastModified || Date.now();
    const url = URL.createObjectURL(file);
    refreshTiles(url);
    watching = true;
    updateMetaFile(fileHandle.name);
    startPolling();
    showOverlay(`${N} × ${N}`);
  } catch (err) {
    console.error('Error loading file:', err);
    alert('Could not load the file. Please try again.');
  }
}

async function startPolling() {
  if (!fileHandle) {
    watching = false;
    return;
  }
  watching = true;
  updateMetaFile(fileHandle.name);
  if (pollTimer) clearInterval(pollTimer);
  pollTimer = setInterval(async () => {
    try {
      const f = await fileHandle.getFile();
      if (!f) return;
      if (f.lastModified !== lastModified) {
        lastModified = f.lastModified;
        const url = URL.createObjectURL(f);
        refreshTiles(url);
      }
    } catch (err) {
      console.warn('Polling error', err);
      stopPolling();
    }
  }, POLL_MS);
}

function stopPolling() {
  if (pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
  }
  watching = false;
  updateMetaFile(fileHandle ? fileHandle.name || 'file' : null);
}

/* ========== Drag & Drop & file choose ========== */
function preventEv(e) {
  e.preventDefault();
  e.stopPropagation();
}
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => {
  window.addEventListener(ev, preventEv);
});

window.addEventListener('drop', async ev => {
  preventEv(ev);
  const dt = ev.dataTransfer;
  if (!dt) return;

  // Try to get a handle for live updates
  if (dt.items && dt.items[0] && typeof dt.items[0].getAsFileSystemHandle === 'function') {
    try {
      const handle = await dt.items[0].getAsFileSystemHandle();
      if (handle && handle.kind === 'file') {
        await loadFileFromHandle(handle);
        return;
      }
    } catch (err) {
      console.warn('Could not get file handle from drop', err);
    }
  }

  // Fallback for browsers that don't support getAsFileSystemHandle
  const file = dt.files && dt.files[0];
  if (file && file.type.startsWith('image/')) {
    const url = URL.createObjectURL(file);
    refreshTiles(url);
    showOverlay(`${N} × ${N}`);
    updateMetaFile(file.name);
    watching = false;
    stopPolling();
  } else {
    alert('Please drop an image file (PNG / JPEG).');
  }
});

chooseFileBtn.addEventListener('click', async () => {
  if (!window.showOpenFilePicker) {
    alert(
      'Your browser does not support the File System Access API. Use a Chromium-based browser (Chrome/Edge) and load the page via http://localhost for full functionality.'
    );
    return;
  }
  try {
    const [handle] = await window.showOpenFilePicker({
      types: [
        {
          description: 'Images',
          accept: { 'image/*': ['.png', '.jpg', '.jpeg', '.webp', '.bmp'] },
        },
      ],
      excludeAcceptAllOption: false,
      multiple: false,
    });
    if (handle) {
      await loadFileFromHandle(handle);
    }
  } catch (err) {
    console.error('File picker cancelled or failed', err);
  }
});

clearBtn.addEventListener('click', () => {
  resetState();
});

gridToggleBtn.addEventListener('click', () => {
  toggleGrid();
});

/* ========== Keyboard & wheel handling ========== */

function setN(newN, { fromUser=true } = {}){
  const clamped = clamp(newN, MIN_N, MAX_N);
  if(clamped === N) return;
  N = clamped;
  renderGrid(); // renderGrid now handles reapplying the image correctly
  if(fromUser) {
    showOverlay(`${N} × ${N}`);
  }
}

window.addEventListener('keydown', (e)=>{
  // allow when stage has focus or always catch
  if(e.key === '+' || e.key === '=' ){
    e.preventDefault();
    setN(N+1);
  } else if(e.key === '-' ){
    e.preventDefault();
    setN(N-1);
  } else if(e.key === 'Home'){
    e.preventDefault();
    setN(MIN_N);
  } else if(e.key === 'End'){
    e.preventDefault();
    setN(MAX_N);
  } else if (e.key === 'g' || e.key === 'G') {
    e.preventDefault();
    toggleGrid();
  }
});

/* Wheel: map deltaY < 0 (wheel away/up) => decrease grid (zoom in) */
stage.addEventListener('wheel', (e)=>{
  // only when pointer over stage
  e.preventDefault();
  const delta = e.deltaY;
  if(delta === 0) return;
  if(delta < 0){ // wheel away / up
    setN(N-1);
  } else {
    setN(N+1);
  }
}, { passive:false });

/* ========== Panning (middle mouse) ========== */
function updatePanPosition() {
  if (!tiles.length || !objectURL) return;
  const tileRect = tiles[0].getBoundingClientRect();
  if (tileRect.width === 0) return;
  const tileWidth = tileRect.width;
  const tileHeight = tileRect.height;

  tiles.forEach((tile, i) => {
    const row = Math.floor(i / N);
    const col = i % N;
    const xPos = panOffset.x - (col * tileWidth);
    const yPos = panOffset.y - (row * tileHeight);
    tile.style.backgroundPosition = `${xPos}px ${yPos}px`;
  });
}

stage.addEventListener('mousedown', e => {
  if (e.button === 1 && objectURL) { // middle mouse
    e.preventDefault();
    isPanning = true;
    panStart.x = e.clientX;
    panStart.y = e.clientY;
    panOffsetAtDragStart.x = panOffset.x;
    panOffsetAtDragStart.y = panOffset.y;
    stage.style.cursor = 'grabbing';
  }
});

window.addEventListener('mousemove', e => {
  if (isPanning) {
    e.preventDefault();
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    panOffset.x = panOffsetAtDragStart.x + dx;
    panOffset.y = panOffsetAtDragStart.y + dy;
    updatePanPosition();
  }
});

window.addEventListener('mouseup', e => {
  if (isPanning && e.button === 1) {
    isPanning = false;
    stage.style.cursor = 'default';
  }
});


/* ========== Touch / pinch handling ========== */
let ongoingTouches = [];
let pinchState = null;

function getDistance(t1, t2){
  const dx = t2.clientX - t1.clientX;
  const dy = t2.clientY - t1.clientY;
  return Math.hypot(dx, dy);
}

stage.addEventListener('touchstart', (ev)=>{
  if(ev.touches.length === 2){
    pinchState = {
      startDist: getDistance(ev.touches[0], ev.touches[1]),
      lastApplied: N
    };
  }
}, { passive:false });

stage.addEventListener('touchmove', (ev)=>{
  if(ev.touches.length === 2 && pinchState){
    ev.preventDefault();
    const curDist = getDistance(ev.touches[0], ev.touches[1]);
    const ratio = curDist / pinchState.startDist;
    // map ratio thresholds to integer steps
    // e.g., every 12% change -> 1 step; this prevents oversensitive jumps
    const step = Math.round(Math.log2(ratio) / Math.log2(1.12)); // approximate
    if(step !== 0){
      const target = clamp(pinchState.lastApplied + step, MIN_N, MAX_N);
      if(target !== N){
        setN(target);
        pinchState.lastApplied = target;
      }
    }
  }
}, { passive:false });

stage.addEventListener('touchend', (ev)=>{
  if(ev.touches.length < 2){
    pinchState = null;
  }
});

/* ========== Initialization ========== */
for (let i = MIN_N; i <= MAX_N; i++) {
  const option = document.createElement('option');
  option.value = i;
  option.textContent = `${i} × ${i}`;
  gridSizeSelect.appendChild(option);
}

gridSizeSelect.addEventListener('change', e => {
  const newN = parseInt(e.target.value, 10);
  setN(newN);
});

renderGrid();
updateMetaFile(null);

/* Expose minimal public API for debug (optional) */
window._liveGrid = {
  setN, renderGrid
};
</script>
</body>
</html>